/**
 *
 * Please note:
 * This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * Do not edit this file manually.
 *
 */

@file:Suppress(
    "ArrayInDataClass",
    "EnumEntryName",
    "RemoveRedundantQualifierName",
    "UnusedImport"
)

package com.cashful.kotlin.sdk.api

import java.io.IOException
import okhttp3.Call
import okhttp3.HttpUrl

import com.cashful.kotlin.sdk.model.AcceptInvitationDto
import com.cashful.kotlin.sdk.model.AcceptInvitationResponseDto
import com.cashful.kotlin.sdk.model.CancelInvitationDto
import com.cashful.kotlin.sdk.model.CancelInvitationResponseDto
import com.cashful.kotlin.sdk.model.ChangeEmailDto
import com.cashful.kotlin.sdk.model.ChangeEmailResponseDto
import com.cashful.kotlin.sdk.model.ChangePasswordDto
import com.cashful.kotlin.sdk.model.ChangePasswordResponseDto
import com.cashful.kotlin.sdk.model.CheckSlugDto
import com.cashful.kotlin.sdk.model.CheckSlugResponseDto
import com.cashful.kotlin.sdk.model.CreateApiKeyDto
import com.cashful.kotlin.sdk.model.CreateApiKeyResponseDto
import com.cashful.kotlin.sdk.model.CreateOrganizationDto
import com.cashful.kotlin.sdk.model.CreateOrganizationResponseDto
import com.cashful.kotlin.sdk.model.DeleteApiKeyDto
import com.cashful.kotlin.sdk.model.DeleteApiKeyResponseDto
import com.cashful.kotlin.sdk.model.DeleteOrganizationDto
import com.cashful.kotlin.sdk.model.DeleteOrganizationResponseDto
import com.cashful.kotlin.sdk.model.DeleteUserDto
import com.cashful.kotlin.sdk.model.DeleteUserResponseDto
import com.cashful.kotlin.sdk.model.ErrorResponseDto
import com.cashful.kotlin.sdk.model.ForgotPasswordDto
import com.cashful.kotlin.sdk.model.ForgotPasswordResponseDto
import com.cashful.kotlin.sdk.model.GetActiveMemberResponseDto
import com.cashful.kotlin.sdk.model.GetActiveMemberRoleResponseDto
import com.cashful.kotlin.sdk.model.GetFullOrganizationResponseDto
import com.cashful.kotlin.sdk.model.GetInvitationResponseDto
import com.cashful.kotlin.sdk.model.GetSessionResponseDto
import com.cashful.kotlin.sdk.model.HasPermissionDto
import com.cashful.kotlin.sdk.model.HasPermissionResponseDto
import com.cashful.kotlin.sdk.model.InviteMemberDto
import com.cashful.kotlin.sdk.model.InviteMemberResponseDto
import com.cashful.kotlin.sdk.model.LeaveOrganizationDto
import com.cashful.kotlin.sdk.model.LeaveOrganizationResponseDto
import com.cashful.kotlin.sdk.model.ListApiKeysResponseDto
import com.cashful.kotlin.sdk.model.ListInvitationsResponseDto
import com.cashful.kotlin.sdk.model.ListMembersResponseDto
import com.cashful.kotlin.sdk.model.ListSessionsResponseDto
import com.cashful.kotlin.sdk.model.ListUserInvitationsResponseDto
import com.cashful.kotlin.sdk.model.OrganizationDto
import com.cashful.kotlin.sdk.model.RejectInvitationDto
import com.cashful.kotlin.sdk.model.RejectInvitationResponseDto
import com.cashful.kotlin.sdk.model.RemoveMemberDto
import com.cashful.kotlin.sdk.model.RemoveMemberResponseDto
import com.cashful.kotlin.sdk.model.RequestPasswordResetDto
import com.cashful.kotlin.sdk.model.RequestPasswordResetResponseDto
import com.cashful.kotlin.sdk.model.ResetPasswordCallbackResponseDto
import com.cashful.kotlin.sdk.model.ResetPasswordDto
import com.cashful.kotlin.sdk.model.ResetPasswordResponseDto
import com.cashful.kotlin.sdk.model.RevokeSessionDto
import com.cashful.kotlin.sdk.model.RevokeSessionResponseDto
import com.cashful.kotlin.sdk.model.SendVerificationEmailDto
import com.cashful.kotlin.sdk.model.SendVerificationEmailResponseDto
import com.cashful.kotlin.sdk.model.SetActiveOrganizationDto
import com.cashful.kotlin.sdk.model.SetActiveOrganizationResponseDto
import com.cashful.kotlin.sdk.model.SignInDto
import com.cashful.kotlin.sdk.model.SignInResponseDto
import com.cashful.kotlin.sdk.model.SignOutResponseDto
import com.cashful.kotlin.sdk.model.SignUpDto
import com.cashful.kotlin.sdk.model.SignUpResponseDto
import com.cashful.kotlin.sdk.model.UpdateApiKeyDto
import com.cashful.kotlin.sdk.model.UpdateApiKeyResponseDto
import com.cashful.kotlin.sdk.model.UpdateMemberRoleDto
import com.cashful.kotlin.sdk.model.UpdateMemberRoleResponseDto
import com.cashful.kotlin.sdk.model.UpdateOrganizationDto
import com.cashful.kotlin.sdk.model.UpdateOrganizationResponseDto
import com.cashful.kotlin.sdk.model.UpdateUserDto
import com.cashful.kotlin.sdk.model.UpdateUserResponseDto
import com.cashful.kotlin.sdk.model.VerifyApiKeyDto
import com.cashful.kotlin.sdk.model.VerifyApiKeyResponseDto
import com.cashful.kotlin.sdk.model.VerifyEmailResponseDto

import kotlinx.serialization.SerialName
import kotlinx.serialization.Serializable

import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.withContext
import com.cashful.kotlin.sdk.infrastructure.ApiClient
import com.cashful.kotlin.sdk.infrastructure.ApiResponse
import com.cashful.kotlin.sdk.infrastructure.ClientException
import com.cashful.kotlin.sdk.infrastructure.ClientError
import com.cashful.kotlin.sdk.infrastructure.ServerException
import com.cashful.kotlin.sdk.infrastructure.ServerError
import com.cashful.kotlin.sdk.infrastructure.MultiValueMap
import com.cashful.kotlin.sdk.infrastructure.PartConfig
import com.cashful.kotlin.sdk.infrastructure.RequestConfig
import com.cashful.kotlin.sdk.infrastructure.RequestMethod
import com.cashful.kotlin.sdk.infrastructure.ResponseType
import com.cashful.kotlin.sdk.infrastructure.Success
import com.cashful.kotlin.sdk.infrastructure.toMultiValue

class AuthenticationApi(basePath: kotlin.String = defaultBasePath, client: Call.Factory = ApiClient.defaultClient) : ApiClient(basePath, client) {
    companion object {
        @JvmStatic
        val defaultBasePath: String by lazy {
            System.getProperties().getProperty(ApiClient.baseUrlKey, "http://localhost:3000")
        }
    }

    /**
     * POST /api/canary/authentication/organization/accept-invitation
     * Accept Invitation
     * Accept an invitation to an organization
     * @param acceptInvitationDto 
     * @return AcceptInvitationResponseDto
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun acceptInvitation(acceptInvitationDto: AcceptInvitationDto) : AcceptInvitationResponseDto = withContext(Dispatchers.IO) {
        val localVarResponse = acceptInvitationWithHttpInfo(acceptInvitationDto = acceptInvitationDto)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as AcceptInvitationResponseDto
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /api/canary/authentication/organization/accept-invitation
     * Accept Invitation
     * Accept an invitation to an organization
     * @param acceptInvitationDto 
     * @return ApiResponse<AcceptInvitationResponseDto?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun acceptInvitationWithHttpInfo(acceptInvitationDto: AcceptInvitationDto) : ApiResponse<AcceptInvitationResponseDto?> = withContext(Dispatchers.IO) {
        val localVariableConfig = acceptInvitationRequestConfig(acceptInvitationDto = acceptInvitationDto)

        return@withContext request<AcceptInvitationDto, AcceptInvitationResponseDto>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation acceptInvitation
     *
     * @param acceptInvitationDto 
     * @return RequestConfig
     */
    fun acceptInvitationRequestConfig(acceptInvitationDto: AcceptInvitationDto) : RequestConfig<AcceptInvitationDto> {
        val localVariableBody = acceptInvitationDto
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/canary/authentication/organization/accept-invitation",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * POST /api/canary/authentication/organization/cancel-invitation
     * Cancel Invitation
     * Cancel an invitation to an organization
     * @param cancelInvitationDto 
     * @return CancelInvitationResponseDto
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun cancelInvitation(cancelInvitationDto: CancelInvitationDto) : CancelInvitationResponseDto = withContext(Dispatchers.IO) {
        val localVarResponse = cancelInvitationWithHttpInfo(cancelInvitationDto = cancelInvitationDto)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as CancelInvitationResponseDto
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /api/canary/authentication/organization/cancel-invitation
     * Cancel Invitation
     * Cancel an invitation to an organization
     * @param cancelInvitationDto 
     * @return ApiResponse<CancelInvitationResponseDto?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun cancelInvitationWithHttpInfo(cancelInvitationDto: CancelInvitationDto) : ApiResponse<CancelInvitationResponseDto?> = withContext(Dispatchers.IO) {
        val localVariableConfig = cancelInvitationRequestConfig(cancelInvitationDto = cancelInvitationDto)

        return@withContext request<CancelInvitationDto, CancelInvitationResponseDto>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation cancelInvitation
     *
     * @param cancelInvitationDto 
     * @return RequestConfig
     */
    fun cancelInvitationRequestConfig(cancelInvitationDto: CancelInvitationDto) : RequestConfig<CancelInvitationDto> {
        val localVariableBody = cancelInvitationDto
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/canary/authentication/organization/cancel-invitation",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * POST /api/canary/authentication/change-email
     * Change Email
     * Change the email address of the current user
     * @param changeEmailDto 
     * @return ChangeEmailResponseDto
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun changeEmail(changeEmailDto: ChangeEmailDto) : ChangeEmailResponseDto = withContext(Dispatchers.IO) {
        val localVarResponse = changeEmailWithHttpInfo(changeEmailDto = changeEmailDto)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ChangeEmailResponseDto
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /api/canary/authentication/change-email
     * Change Email
     * Change the email address of the current user
     * @param changeEmailDto 
     * @return ApiResponse<ChangeEmailResponseDto?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun changeEmailWithHttpInfo(changeEmailDto: ChangeEmailDto) : ApiResponse<ChangeEmailResponseDto?> = withContext(Dispatchers.IO) {
        val localVariableConfig = changeEmailRequestConfig(changeEmailDto = changeEmailDto)

        return@withContext request<ChangeEmailDto, ChangeEmailResponseDto>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation changeEmail
     *
     * @param changeEmailDto 
     * @return RequestConfig
     */
    fun changeEmailRequestConfig(changeEmailDto: ChangeEmailDto) : RequestConfig<ChangeEmailDto> {
        val localVariableBody = changeEmailDto
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/canary/authentication/change-email",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * POST /api/canary/authentication/change-password
     * Change Password
     * Change the password of the current user
     * @param changePasswordDto 
     * @return ChangePasswordResponseDto
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun changePassword(changePasswordDto: ChangePasswordDto) : ChangePasswordResponseDto = withContext(Dispatchers.IO) {
        val localVarResponse = changePasswordWithHttpInfo(changePasswordDto = changePasswordDto)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ChangePasswordResponseDto
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /api/canary/authentication/change-password
     * Change Password
     * Change the password of the current user
     * @param changePasswordDto 
     * @return ApiResponse<ChangePasswordResponseDto?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun changePasswordWithHttpInfo(changePasswordDto: ChangePasswordDto) : ApiResponse<ChangePasswordResponseDto?> = withContext(Dispatchers.IO) {
        val localVariableConfig = changePasswordRequestConfig(changePasswordDto = changePasswordDto)

        return@withContext request<ChangePasswordDto, ChangePasswordResponseDto>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation changePassword
     *
     * @param changePasswordDto 
     * @return RequestConfig
     */
    fun changePasswordRequestConfig(changePasswordDto: ChangePasswordDto) : RequestConfig<ChangePasswordDto> {
        val localVariableBody = changePasswordDto
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/canary/authentication/change-password",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * POST /api/canary/authentication/organization/check-slug
     * Check Slug
     * Check if organization slug is available
     * @param checkSlugDto 
     * @return CheckSlugResponseDto
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun checkSlug(checkSlugDto: CheckSlugDto) : CheckSlugResponseDto = withContext(Dispatchers.IO) {
        val localVarResponse = checkSlugWithHttpInfo(checkSlugDto = checkSlugDto)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as CheckSlugResponseDto
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /api/canary/authentication/organization/check-slug
     * Check Slug
     * Check if organization slug is available
     * @param checkSlugDto 
     * @return ApiResponse<CheckSlugResponseDto?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun checkSlugWithHttpInfo(checkSlugDto: CheckSlugDto) : ApiResponse<CheckSlugResponseDto?> = withContext(Dispatchers.IO) {
        val localVariableConfig = checkSlugRequestConfig(checkSlugDto = checkSlugDto)

        return@withContext request<CheckSlugDto, CheckSlugResponseDto>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation checkSlug
     *
     * @param checkSlugDto 
     * @return RequestConfig
     */
    fun checkSlugRequestConfig(checkSlugDto: CheckSlugDto) : RequestConfig<CheckSlugDto> {
        val localVariableBody = checkSlugDto
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/canary/authentication/organization/check-slug",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * POST /api/canary/authentication/api-key/create
     * Create API Key
     * Create a new API key
     * @param createApiKeyDto 
     * @return CreateApiKeyResponseDto
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun createApiKey(createApiKeyDto: CreateApiKeyDto) : CreateApiKeyResponseDto = withContext(Dispatchers.IO) {
        val localVarResponse = createApiKeyWithHttpInfo(createApiKeyDto = createApiKeyDto)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as CreateApiKeyResponseDto
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /api/canary/authentication/api-key/create
     * Create API Key
     * Create a new API key
     * @param createApiKeyDto 
     * @return ApiResponse<CreateApiKeyResponseDto?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun createApiKeyWithHttpInfo(createApiKeyDto: CreateApiKeyDto) : ApiResponse<CreateApiKeyResponseDto?> = withContext(Dispatchers.IO) {
        val localVariableConfig = createApiKeyRequestConfig(createApiKeyDto = createApiKeyDto)

        return@withContext request<CreateApiKeyDto, CreateApiKeyResponseDto>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation createApiKey
     *
     * @param createApiKeyDto 
     * @return RequestConfig
     */
    fun createApiKeyRequestConfig(createApiKeyDto: CreateApiKeyDto) : RequestConfig<CreateApiKeyDto> {
        val localVariableBody = createApiKeyDto
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/canary/authentication/api-key/create",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * POST /api/canary/authentication/organization/create
     * Create Organization
     * Create a new organization
     * @param createOrganizationDto 
     * @return CreateOrganizationResponseDto
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun createOrganization(createOrganizationDto: CreateOrganizationDto) : CreateOrganizationResponseDto = withContext(Dispatchers.IO) {
        val localVarResponse = createOrganizationWithHttpInfo(createOrganizationDto = createOrganizationDto)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as CreateOrganizationResponseDto
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /api/canary/authentication/organization/create
     * Create Organization
     * Create a new organization
     * @param createOrganizationDto 
     * @return ApiResponse<CreateOrganizationResponseDto?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun createOrganizationWithHttpInfo(createOrganizationDto: CreateOrganizationDto) : ApiResponse<CreateOrganizationResponseDto?> = withContext(Dispatchers.IO) {
        val localVariableConfig = createOrganizationRequestConfig(createOrganizationDto = createOrganizationDto)

        return@withContext request<CreateOrganizationDto, CreateOrganizationResponseDto>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation createOrganization
     *
     * @param createOrganizationDto 
     * @return RequestConfig
     */
    fun createOrganizationRequestConfig(createOrganizationDto: CreateOrganizationDto) : RequestConfig<CreateOrganizationDto> {
        val localVariableBody = createOrganizationDto
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/canary/authentication/organization/create",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * POST /api/canary/authentication/api-key/delete
     * Delete API Key
     * Delete an API key
     * @param deleteApiKeyDto 
     * @return DeleteApiKeyResponseDto
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun deleteApiKey(deleteApiKeyDto: DeleteApiKeyDto) : DeleteApiKeyResponseDto = withContext(Dispatchers.IO) {
        val localVarResponse = deleteApiKeyWithHttpInfo(deleteApiKeyDto = deleteApiKeyDto)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as DeleteApiKeyResponseDto
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /api/canary/authentication/api-key/delete
     * Delete API Key
     * Delete an API key
     * @param deleteApiKeyDto 
     * @return ApiResponse<DeleteApiKeyResponseDto?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun deleteApiKeyWithHttpInfo(deleteApiKeyDto: DeleteApiKeyDto) : ApiResponse<DeleteApiKeyResponseDto?> = withContext(Dispatchers.IO) {
        val localVariableConfig = deleteApiKeyRequestConfig(deleteApiKeyDto = deleteApiKeyDto)

        return@withContext request<DeleteApiKeyDto, DeleteApiKeyResponseDto>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation deleteApiKey
     *
     * @param deleteApiKeyDto 
     * @return RequestConfig
     */
    fun deleteApiKeyRequestConfig(deleteApiKeyDto: DeleteApiKeyDto) : RequestConfig<DeleteApiKeyDto> {
        val localVariableBody = deleteApiKeyDto
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/canary/authentication/api-key/delete",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * POST /api/canary/authentication/organization/delete
     * Delete Organization
     * Delete an organization
     * @param deleteOrganizationDto 
     * @return DeleteOrganizationResponseDto
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun deleteOrganization(deleteOrganizationDto: DeleteOrganizationDto) : DeleteOrganizationResponseDto = withContext(Dispatchers.IO) {
        val localVarResponse = deleteOrganizationWithHttpInfo(deleteOrganizationDto = deleteOrganizationDto)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as DeleteOrganizationResponseDto
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /api/canary/authentication/organization/delete
     * Delete Organization
     * Delete an organization
     * @param deleteOrganizationDto 
     * @return ApiResponse<DeleteOrganizationResponseDto?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun deleteOrganizationWithHttpInfo(deleteOrganizationDto: DeleteOrganizationDto) : ApiResponse<DeleteOrganizationResponseDto?> = withContext(Dispatchers.IO) {
        val localVariableConfig = deleteOrganizationRequestConfig(deleteOrganizationDto = deleteOrganizationDto)

        return@withContext request<DeleteOrganizationDto, DeleteOrganizationResponseDto>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation deleteOrganization
     *
     * @param deleteOrganizationDto 
     * @return RequestConfig
     */
    fun deleteOrganizationRequestConfig(deleteOrganizationDto: DeleteOrganizationDto) : RequestConfig<DeleteOrganizationDto> {
        val localVariableBody = deleteOrganizationDto
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/canary/authentication/organization/delete",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * POST /api/canary/authentication/delete-user
     * Delete User
     * Delete the current user&#39;s account
     * @param deleteUserDto 
     * @return DeleteUserResponseDto
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun deleteUser(deleteUserDto: DeleteUserDto) : DeleteUserResponseDto = withContext(Dispatchers.IO) {
        val localVarResponse = deleteUserWithHttpInfo(deleteUserDto = deleteUserDto)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as DeleteUserResponseDto
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /api/canary/authentication/delete-user
     * Delete User
     * Delete the current user&#39;s account
     * @param deleteUserDto 
     * @return ApiResponse<DeleteUserResponseDto?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun deleteUserWithHttpInfo(deleteUserDto: DeleteUserDto) : ApiResponse<DeleteUserResponseDto?> = withContext(Dispatchers.IO) {
        val localVariableConfig = deleteUserRequestConfig(deleteUserDto = deleteUserDto)

        return@withContext request<DeleteUserDto, DeleteUserResponseDto>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation deleteUser
     *
     * @param deleteUserDto 
     * @return RequestConfig
     */
    fun deleteUserRequestConfig(deleteUserDto: DeleteUserDto) : RequestConfig<DeleteUserDto> {
        val localVariableBody = deleteUserDto
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/canary/authentication/delete-user",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * POST /api/canary/authentication/forget-password
     * Forget Password
     * Send a password reset email to the user
     * @param forgotPasswordDto 
     * @return ForgotPasswordResponseDto
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun forgetPassword(forgotPasswordDto: ForgotPasswordDto) : ForgotPasswordResponseDto = withContext(Dispatchers.IO) {
        val localVarResponse = forgetPasswordWithHttpInfo(forgotPasswordDto = forgotPasswordDto)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ForgotPasswordResponseDto
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /api/canary/authentication/forget-password
     * Forget Password
     * Send a password reset email to the user
     * @param forgotPasswordDto 
     * @return ApiResponse<ForgotPasswordResponseDto?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun forgetPasswordWithHttpInfo(forgotPasswordDto: ForgotPasswordDto) : ApiResponse<ForgotPasswordResponseDto?> = withContext(Dispatchers.IO) {
        val localVariableConfig = forgetPasswordRequestConfig(forgotPasswordDto = forgotPasswordDto)

        return@withContext request<ForgotPasswordDto, ForgotPasswordResponseDto>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation forgetPassword
     *
     * @param forgotPasswordDto 
     * @return RequestConfig
     */
    fun forgetPasswordRequestConfig(forgotPasswordDto: ForgotPasswordDto) : RequestConfig<ForgotPasswordDto> {
        val localVariableBody = forgotPasswordDto
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/canary/authentication/forget-password",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * GET /api/canary/authentication/organization/get-active-member
     * Get Active Member
     * Get the member details of the active organization
     * @param organizationId Filter by organization ID (optional)
     * @return GetActiveMemberResponseDto
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun getActiveMember(organizationId: kotlin.String? = null) : GetActiveMemberResponseDto = withContext(Dispatchers.IO) {
        val localVarResponse = getActiveMemberWithHttpInfo(organizationId = organizationId)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as GetActiveMemberResponseDto
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /api/canary/authentication/organization/get-active-member
     * Get Active Member
     * Get the member details of the active organization
     * @param organizationId Filter by organization ID (optional)
     * @return ApiResponse<GetActiveMemberResponseDto?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun getActiveMemberWithHttpInfo(organizationId: kotlin.String?) : ApiResponse<GetActiveMemberResponseDto?> = withContext(Dispatchers.IO) {
        val localVariableConfig = getActiveMemberRequestConfig(organizationId = organizationId)

        return@withContext request<Unit, GetActiveMemberResponseDto>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getActiveMember
     *
     * @param organizationId Filter by organization ID (optional)
     * @return RequestConfig
     */
    fun getActiveMemberRequestConfig(organizationId: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (organizationId != null) {
                    put("organizationId", listOf(organizationId.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/canary/authentication/organization/get-active-member",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * GET /api/canary/authentication/organization/get-active-member-role
     * Get Active Member Role
     * Get the role of the current user in the active organization
     * @param organizationId Filter by organization ID (optional)
     * @return GetActiveMemberRoleResponseDto
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun getActiveMemberRole(organizationId: kotlin.String? = null) : GetActiveMemberRoleResponseDto = withContext(Dispatchers.IO) {
        val localVarResponse = getActiveMemberRoleWithHttpInfo(organizationId = organizationId)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as GetActiveMemberRoleResponseDto
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /api/canary/authentication/organization/get-active-member-role
     * Get Active Member Role
     * Get the role of the current user in the active organization
     * @param organizationId Filter by organization ID (optional)
     * @return ApiResponse<GetActiveMemberRoleResponseDto?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun getActiveMemberRoleWithHttpInfo(organizationId: kotlin.String?) : ApiResponse<GetActiveMemberRoleResponseDto?> = withContext(Dispatchers.IO) {
        val localVariableConfig = getActiveMemberRoleRequestConfig(organizationId = organizationId)

        return@withContext request<Unit, GetActiveMemberRoleResponseDto>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getActiveMemberRole
     *
     * @param organizationId Filter by organization ID (optional)
     * @return RequestConfig
     */
    fun getActiveMemberRoleRequestConfig(organizationId: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (organizationId != null) {
                    put("organizationId", listOf(organizationId.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/canary/authentication/organization/get-active-member-role",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * GET /api/canary/authentication/organization/get-invitation
     * Get Invitation
     * Get an invitation by ID
     * @param invitationId The ID of the invitation to get
     * @return GetInvitationResponseDto
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun getInvitation(invitationId: kotlin.String) : GetInvitationResponseDto = withContext(Dispatchers.IO) {
        val localVarResponse = getInvitationWithHttpInfo(invitationId = invitationId)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as GetInvitationResponseDto
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /api/canary/authentication/organization/get-invitation
     * Get Invitation
     * Get an invitation by ID
     * @param invitationId The ID of the invitation to get
     * @return ApiResponse<GetInvitationResponseDto?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun getInvitationWithHttpInfo(invitationId: kotlin.String) : ApiResponse<GetInvitationResponseDto?> = withContext(Dispatchers.IO) {
        val localVariableConfig = getInvitationRequestConfig(invitationId = invitationId)

        return@withContext request<Unit, GetInvitationResponseDto>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getInvitation
     *
     * @param invitationId The ID of the invitation to get
     * @return RequestConfig
     */
    fun getInvitationRequestConfig(invitationId: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("invitationId", listOf(invitationId.toString()))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/canary/authentication/organization/get-invitation",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * GET /api/canary/authentication/organization/get-full-organization
     * Get Full Organization
     * Get the full organization details
     * @param organizationId The organization ID to get (optional)
     * @return GetFullOrganizationResponseDto
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun getOrganization(organizationId: kotlin.String? = null) : GetFullOrganizationResponseDto = withContext(Dispatchers.IO) {
        val localVarResponse = getOrganizationWithHttpInfo(organizationId = organizationId)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as GetFullOrganizationResponseDto
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /api/canary/authentication/organization/get-full-organization
     * Get Full Organization
     * Get the full organization details
     * @param organizationId The organization ID to get (optional)
     * @return ApiResponse<GetFullOrganizationResponseDto?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun getOrganizationWithHttpInfo(organizationId: kotlin.String?) : ApiResponse<GetFullOrganizationResponseDto?> = withContext(Dispatchers.IO) {
        val localVariableConfig = getOrganizationRequestConfig(organizationId = organizationId)

        return@withContext request<Unit, GetFullOrganizationResponseDto>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getOrganization
     *
     * @param organizationId The organization ID to get (optional)
     * @return RequestConfig
     */
    fun getOrganizationRequestConfig(organizationId: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (organizationId != null) {
                    put("organizationId", listOf(organizationId.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/canary/authentication/organization/get-full-organization",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * GET /api/canary/authentication/get-session
     * Get Session
     * Retrieve the current user session
     * @return GetSessionResponseDto
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun getSession() : GetSessionResponseDto = withContext(Dispatchers.IO) {
        val localVarResponse = getSessionWithHttpInfo()

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as GetSessionResponseDto
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /api/canary/authentication/get-session
     * Get Session
     * Retrieve the current user session
     * @return ApiResponse<GetSessionResponseDto?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun getSessionWithHttpInfo() : ApiResponse<GetSessionResponseDto?> = withContext(Dispatchers.IO) {
        val localVariableConfig = getSessionRequestConfig()

        return@withContext request<Unit, GetSessionResponseDto>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getSession
     *
     * @return RequestConfig
     */
    fun getSessionRequestConfig() : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/canary/authentication/get-session",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * POST /api/canary/authentication/organization/has-permission
     * Has Permission
     * Check if a user has permission
     * @param hasPermissionDto 
     * @return HasPermissionResponseDto
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun hasPermission(hasPermissionDto: HasPermissionDto) : HasPermissionResponseDto = withContext(Dispatchers.IO) {
        val localVarResponse = hasPermissionWithHttpInfo(hasPermissionDto = hasPermissionDto)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as HasPermissionResponseDto
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /api/canary/authentication/organization/has-permission
     * Has Permission
     * Check if a user has permission
     * @param hasPermissionDto 
     * @return ApiResponse<HasPermissionResponseDto?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun hasPermissionWithHttpInfo(hasPermissionDto: HasPermissionDto) : ApiResponse<HasPermissionResponseDto?> = withContext(Dispatchers.IO) {
        val localVariableConfig = hasPermissionRequestConfig(hasPermissionDto = hasPermissionDto)

        return@withContext request<HasPermissionDto, HasPermissionResponseDto>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation hasPermission
     *
     * @param hasPermissionDto 
     * @return RequestConfig
     */
    fun hasPermissionRequestConfig(hasPermissionDto: HasPermissionDto) : RequestConfig<HasPermissionDto> {
        val localVariableBody = hasPermissionDto
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/canary/authentication/organization/has-permission",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * POST /api/canary/authentication/organization/invite-member
     * Invite Member
     * Invite a user to an organization
     * @param inviteMemberDto 
     * @return InviteMemberResponseDto
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun inviteMember(inviteMemberDto: InviteMemberDto) : InviteMemberResponseDto = withContext(Dispatchers.IO) {
        val localVarResponse = inviteMemberWithHttpInfo(inviteMemberDto = inviteMemberDto)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as InviteMemberResponseDto
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /api/canary/authentication/organization/invite-member
     * Invite Member
     * Invite a user to an organization
     * @param inviteMemberDto 
     * @return ApiResponse<InviteMemberResponseDto?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun inviteMemberWithHttpInfo(inviteMemberDto: InviteMemberDto) : ApiResponse<InviteMemberResponseDto?> = withContext(Dispatchers.IO) {
        val localVariableConfig = inviteMemberRequestConfig(inviteMemberDto = inviteMemberDto)

        return@withContext request<InviteMemberDto, InviteMemberResponseDto>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation inviteMember
     *
     * @param inviteMemberDto 
     * @return RequestConfig
     */
    fun inviteMemberRequestConfig(inviteMemberDto: InviteMemberDto) : RequestConfig<InviteMemberDto> {
        val localVariableBody = inviteMemberDto
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/canary/authentication/organization/invite-member",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * POST /api/canary/authentication/organization/leave
     * Leave Organization
     * Leave an organization
     * @param leaveOrganizationDto 
     * @return LeaveOrganizationResponseDto
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun leaveOrganization(leaveOrganizationDto: LeaveOrganizationDto) : LeaveOrganizationResponseDto = withContext(Dispatchers.IO) {
        val localVarResponse = leaveOrganizationWithHttpInfo(leaveOrganizationDto = leaveOrganizationDto)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as LeaveOrganizationResponseDto
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /api/canary/authentication/organization/leave
     * Leave Organization
     * Leave an organization
     * @param leaveOrganizationDto 
     * @return ApiResponse<LeaveOrganizationResponseDto?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun leaveOrganizationWithHttpInfo(leaveOrganizationDto: LeaveOrganizationDto) : ApiResponse<LeaveOrganizationResponseDto?> = withContext(Dispatchers.IO) {
        val localVariableConfig = leaveOrganizationRequestConfig(leaveOrganizationDto = leaveOrganizationDto)

        return@withContext request<LeaveOrganizationDto, LeaveOrganizationResponseDto>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation leaveOrganization
     *
     * @param leaveOrganizationDto 
     * @return RequestConfig
     */
    fun leaveOrganizationRequestConfig(leaveOrganizationDto: LeaveOrganizationDto) : RequestConfig<LeaveOrganizationDto> {
        val localVariableBody = leaveOrganizationDto
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/canary/authentication/organization/leave",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * GET /api/canary/authentication/api-key/list
     * List API Keys
     * List all API keys for the current user
     * @return ListApiKeysResponseDto
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun listApiKeys() : ListApiKeysResponseDto = withContext(Dispatchers.IO) {
        val localVarResponse = listApiKeysWithHttpInfo()

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ListApiKeysResponseDto
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /api/canary/authentication/api-key/list
     * List API Keys
     * List all API keys for the current user
     * @return ApiResponse<ListApiKeysResponseDto?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun listApiKeysWithHttpInfo() : ApiResponse<ListApiKeysResponseDto?> = withContext(Dispatchers.IO) {
        val localVariableConfig = listApiKeysRequestConfig()

        return@withContext request<Unit, ListApiKeysResponseDto>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation listApiKeys
     *
     * @return RequestConfig
     */
    fun listApiKeysRequestConfig() : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/canary/authentication/api-key/list",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * GET /api/canary/authentication/organization/list-members
     * List Members
     * List all members of an organization
     * @param organizationId Filter by organization ID (optional)
     * @return ListMembersResponseDto
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun listMembers(organizationId: kotlin.String? = null) : ListMembersResponseDto = withContext(Dispatchers.IO) {
        val localVarResponse = listMembersWithHttpInfo(organizationId = organizationId)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ListMembersResponseDto
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /api/canary/authentication/organization/list-members
     * List Members
     * List all members of an organization
     * @param organizationId Filter by organization ID (optional)
     * @return ApiResponse<ListMembersResponseDto?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun listMembersWithHttpInfo(organizationId: kotlin.String?) : ApiResponse<ListMembersResponseDto?> = withContext(Dispatchers.IO) {
        val localVariableConfig = listMembersRequestConfig(organizationId = organizationId)

        return@withContext request<Unit, ListMembersResponseDto>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation listMembers
     *
     * @param organizationId Filter by organization ID (optional)
     * @return RequestConfig
     */
    fun listMembersRequestConfig(organizationId: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (organizationId != null) {
                    put("organizationId", listOf(organizationId.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/canary/authentication/organization/list-members",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * GET /api/canary/authentication/organization/list-invitations
     * List Invitations
     * List all invitations a user has received
     * @param organizationId Filter by organization ID (optional)
     * @return ListInvitationsResponseDto
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun listOrganizationInvitations(organizationId: kotlin.String? = null) : ListInvitationsResponseDto = withContext(Dispatchers.IO) {
        val localVarResponse = listOrganizationInvitationsWithHttpInfo(organizationId = organizationId)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ListInvitationsResponseDto
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /api/canary/authentication/organization/list-invitations
     * List Invitations
     * List all invitations a user has received
     * @param organizationId Filter by organization ID (optional)
     * @return ApiResponse<ListInvitationsResponseDto?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun listOrganizationInvitationsWithHttpInfo(organizationId: kotlin.String?) : ApiResponse<ListInvitationsResponseDto?> = withContext(Dispatchers.IO) {
        val localVariableConfig = listOrganizationInvitationsRequestConfig(organizationId = organizationId)

        return@withContext request<Unit, ListInvitationsResponseDto>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation listOrganizationInvitations
     *
     * @param organizationId Filter by organization ID (optional)
     * @return RequestConfig
     */
    fun listOrganizationInvitationsRequestConfig(organizationId: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (organizationId != null) {
                    put("organizationId", listOf(organizationId.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/canary/authentication/organization/list-invitations",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * GET /api/canary/authentication/organization/list
     * List Organizations
     * List all organizations for the current user
     * @param include Include additional organization data (optional)
     * @return kotlin.collections.List<OrganizationDto>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun listOrganizations(include: kotlin.Boolean? = null) : kotlin.collections.List<OrganizationDto> = withContext(Dispatchers.IO) {
        val localVarResponse = listOrganizationsWithHttpInfo(include = include)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<OrganizationDto>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /api/canary/authentication/organization/list
     * List Organizations
     * List all organizations for the current user
     * @param include Include additional organization data (optional)
     * @return ApiResponse<kotlin.collections.List<OrganizationDto>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun listOrganizationsWithHttpInfo(include: kotlin.Boolean?) : ApiResponse<kotlin.collections.List<OrganizationDto>?> = withContext(Dispatchers.IO) {
        val localVariableConfig = listOrganizationsRequestConfig(include = include)

        return@withContext request<Unit, kotlin.collections.List<OrganizationDto>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation listOrganizations
     *
     * @param include Include additional organization data (optional)
     * @return RequestConfig
     */
    fun listOrganizationsRequestConfig(include: kotlin.Boolean?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (include != null) {
                    put("include", listOf(include.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/canary/authentication/organization/list",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * GET /api/canary/authentication/organization/list-user-invitations
     * List User Invitations
     * List all invitations a user has received
     * @param status Filter by status (optional)
     * @return ListUserInvitationsResponseDto
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun listUserInvitations(status: kotlin.String? = null) : ListUserInvitationsResponseDto = withContext(Dispatchers.IO) {
        val localVarResponse = listUserInvitationsWithHttpInfo(status = status)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ListUserInvitationsResponseDto
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /api/canary/authentication/organization/list-user-invitations
     * List User Invitations
     * List all invitations a user has received
     * @param status Filter by status (optional)
     * @return ApiResponse<ListUserInvitationsResponseDto?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun listUserInvitationsWithHttpInfo(status: kotlin.String?) : ApiResponse<ListUserInvitationsResponseDto?> = withContext(Dispatchers.IO) {
        val localVariableConfig = listUserInvitationsRequestConfig(status = status)

        return@withContext request<Unit, ListUserInvitationsResponseDto>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation listUserInvitations
     *
     * @param status Filter by status (optional)
     * @return RequestConfig
     */
    fun listUserInvitationsRequestConfig(status: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (status != null) {
                    put("status", listOf(status.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/canary/authentication/organization/list-user-invitations",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * GET /api/canary/authentication/list-sessions
     * List User Sessions
     * List all active sessions for the user
     * @return ListSessionsResponseDto
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun listUserSessions() : ListSessionsResponseDto = withContext(Dispatchers.IO) {
        val localVarResponse = listUserSessionsWithHttpInfo()

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ListSessionsResponseDto
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /api/canary/authentication/list-sessions
     * List User Sessions
     * List all active sessions for the user
     * @return ApiResponse<ListSessionsResponseDto?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun listUserSessionsWithHttpInfo() : ApiResponse<ListSessionsResponseDto?> = withContext(Dispatchers.IO) {
        val localVariableConfig = listUserSessionsRequestConfig()

        return@withContext request<Unit, ListSessionsResponseDto>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation listUserSessions
     *
     * @return RequestConfig
     */
    fun listUserSessionsRequestConfig() : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/canary/authentication/list-sessions",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * POST /api/canary/authentication/organization/reject-invitation
     * Reject Invitation
     * Reject an invitation to an organization
     * @param rejectInvitationDto 
     * @return RejectInvitationResponseDto
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun rejectInvitation(rejectInvitationDto: RejectInvitationDto) : RejectInvitationResponseDto = withContext(Dispatchers.IO) {
        val localVarResponse = rejectInvitationWithHttpInfo(rejectInvitationDto = rejectInvitationDto)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as RejectInvitationResponseDto
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /api/canary/authentication/organization/reject-invitation
     * Reject Invitation
     * Reject an invitation to an organization
     * @param rejectInvitationDto 
     * @return ApiResponse<RejectInvitationResponseDto?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun rejectInvitationWithHttpInfo(rejectInvitationDto: RejectInvitationDto) : ApiResponse<RejectInvitationResponseDto?> = withContext(Dispatchers.IO) {
        val localVariableConfig = rejectInvitationRequestConfig(rejectInvitationDto = rejectInvitationDto)

        return@withContext request<RejectInvitationDto, RejectInvitationResponseDto>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation rejectInvitation
     *
     * @param rejectInvitationDto 
     * @return RequestConfig
     */
    fun rejectInvitationRequestConfig(rejectInvitationDto: RejectInvitationDto) : RequestConfig<RejectInvitationDto> {
        val localVariableBody = rejectInvitationDto
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/canary/authentication/organization/reject-invitation",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * POST /api/canary/authentication/organization/remove-member
     * Remove Member
     * Remove a member from an organization
     * @param removeMemberDto 
     * @return RemoveMemberResponseDto
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun removeMember(removeMemberDto: RemoveMemberDto) : RemoveMemberResponseDto = withContext(Dispatchers.IO) {
        val localVarResponse = removeMemberWithHttpInfo(removeMemberDto = removeMemberDto)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as RemoveMemberResponseDto
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /api/canary/authentication/organization/remove-member
     * Remove Member
     * Remove a member from an organization
     * @param removeMemberDto 
     * @return ApiResponse<RemoveMemberResponseDto?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun removeMemberWithHttpInfo(removeMemberDto: RemoveMemberDto) : ApiResponse<RemoveMemberResponseDto?> = withContext(Dispatchers.IO) {
        val localVariableConfig = removeMemberRequestConfig(removeMemberDto = removeMemberDto)

        return@withContext request<RemoveMemberDto, RemoveMemberResponseDto>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation removeMember
     *
     * @param removeMemberDto 
     * @return RequestConfig
     */
    fun removeMemberRequestConfig(removeMemberDto: RemoveMemberDto) : RequestConfig<RemoveMemberDto> {
        val localVariableBody = removeMemberDto
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/canary/authentication/organization/remove-member",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * POST /api/canary/authentication/request-password-reset
     * Request Password Reset
     * Send a password reset email to the user
     * @param requestPasswordResetDto 
     * @return RequestPasswordResetResponseDto
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun requestPasswordReset(requestPasswordResetDto: RequestPasswordResetDto) : RequestPasswordResetResponseDto = withContext(Dispatchers.IO) {
        val localVarResponse = requestPasswordResetWithHttpInfo(requestPasswordResetDto = requestPasswordResetDto)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as RequestPasswordResetResponseDto
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /api/canary/authentication/request-password-reset
     * Request Password Reset
     * Send a password reset email to the user
     * @param requestPasswordResetDto 
     * @return ApiResponse<RequestPasswordResetResponseDto?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun requestPasswordResetWithHttpInfo(requestPasswordResetDto: RequestPasswordResetDto) : ApiResponse<RequestPasswordResetResponseDto?> = withContext(Dispatchers.IO) {
        val localVariableConfig = requestPasswordResetRequestConfig(requestPasswordResetDto = requestPasswordResetDto)

        return@withContext request<RequestPasswordResetDto, RequestPasswordResetResponseDto>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation requestPasswordReset
     *
     * @param requestPasswordResetDto 
     * @return RequestConfig
     */
    fun requestPasswordResetRequestConfig(requestPasswordResetDto: RequestPasswordResetDto) : RequestConfig<RequestPasswordResetDto> {
        val localVariableBody = requestPasswordResetDto
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/canary/authentication/request-password-reset",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * POST /api/canary/authentication/reset-password
     * Reset Password
     * Reset the user&#39;s password using a token
     * @param resetPasswordDto 
     * @return ResetPasswordResponseDto
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun resetPassword(resetPasswordDto: ResetPasswordDto) : ResetPasswordResponseDto = withContext(Dispatchers.IO) {
        val localVarResponse = resetPasswordWithHttpInfo(resetPasswordDto = resetPasswordDto)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ResetPasswordResponseDto
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /api/canary/authentication/reset-password
     * Reset Password
     * Reset the user&#39;s password using a token
     * @param resetPasswordDto 
     * @return ApiResponse<ResetPasswordResponseDto?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun resetPasswordWithHttpInfo(resetPasswordDto: ResetPasswordDto) : ApiResponse<ResetPasswordResponseDto?> = withContext(Dispatchers.IO) {
        val localVariableConfig = resetPasswordRequestConfig(resetPasswordDto = resetPasswordDto)

        return@withContext request<ResetPasswordDto, ResetPasswordResponseDto>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation resetPassword
     *
     * @param resetPasswordDto 
     * @return RequestConfig
     */
    fun resetPasswordRequestConfig(resetPasswordDto: ResetPasswordDto) : RequestConfig<ResetPasswordDto> {
        val localVariableBody = resetPasswordDto
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/canary/authentication/reset-password",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * GET /api/canary/authentication/reset-password/{token}
     * Reset Password Callback
     * Redirects user to callback URL with token
     * @param token 
     * @param callbackURL 
     * @return ResetPasswordCallbackResponseDto
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun resetPasswordCallback(token: kotlin.String, callbackURL: kotlin.String) : ResetPasswordCallbackResponseDto = withContext(Dispatchers.IO) {
        val localVarResponse = resetPasswordCallbackWithHttpInfo(token = token, callbackURL = callbackURL)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ResetPasswordCallbackResponseDto
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /api/canary/authentication/reset-password/{token}
     * Reset Password Callback
     * Redirects user to callback URL with token
     * @param token 
     * @param callbackURL 
     * @return ApiResponse<ResetPasswordCallbackResponseDto?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun resetPasswordCallbackWithHttpInfo(token: kotlin.String, callbackURL: kotlin.String) : ApiResponse<ResetPasswordCallbackResponseDto?> = withContext(Dispatchers.IO) {
        val localVariableConfig = resetPasswordCallbackRequestConfig(token = token, callbackURL = callbackURL)

        return@withContext request<Unit, ResetPasswordCallbackResponseDto>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation resetPasswordCallback
     *
     * @param token 
     * @param callbackURL 
     * @return RequestConfig
     */
    fun resetPasswordCallbackRequestConfig(token: kotlin.String, callbackURL: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("callbackURL", listOf(callbackURL.toString()))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/canary/authentication/reset-password/{token}".replace("{"+"token"+"}", encodeURIComponent(token.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * POST /api/canary/authentication/revoke-session
     * Revoke Session
     * Revoke a specific session
     * @param revokeSessionDto 
     * @return RevokeSessionResponseDto
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun revokeSession(revokeSessionDto: RevokeSessionDto) : RevokeSessionResponseDto = withContext(Dispatchers.IO) {
        val localVarResponse = revokeSessionWithHttpInfo(revokeSessionDto = revokeSessionDto)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as RevokeSessionResponseDto
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /api/canary/authentication/revoke-session
     * Revoke Session
     * Revoke a specific session
     * @param revokeSessionDto 
     * @return ApiResponse<RevokeSessionResponseDto?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun revokeSessionWithHttpInfo(revokeSessionDto: RevokeSessionDto) : ApiResponse<RevokeSessionResponseDto?> = withContext(Dispatchers.IO) {
        val localVariableConfig = revokeSessionRequestConfig(revokeSessionDto = revokeSessionDto)

        return@withContext request<RevokeSessionDto, RevokeSessionResponseDto>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation revokeSession
     *
     * @param revokeSessionDto 
     * @return RequestConfig
     */
    fun revokeSessionRequestConfig(revokeSessionDto: RevokeSessionDto) : RequestConfig<RevokeSessionDto> {
        val localVariableBody = revokeSessionDto
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/canary/authentication/revoke-session",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * POST /api/canary/authentication/send-verification-email
     * Send Verification Email
     * Send a verification email to the user
     * @param sendVerificationEmailDto 
     * @return SendVerificationEmailResponseDto
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun sendVerificationEmail(sendVerificationEmailDto: SendVerificationEmailDto) : SendVerificationEmailResponseDto = withContext(Dispatchers.IO) {
        val localVarResponse = sendVerificationEmailWithHttpInfo(sendVerificationEmailDto = sendVerificationEmailDto)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as SendVerificationEmailResponseDto
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /api/canary/authentication/send-verification-email
     * Send Verification Email
     * Send a verification email to the user
     * @param sendVerificationEmailDto 
     * @return ApiResponse<SendVerificationEmailResponseDto?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun sendVerificationEmailWithHttpInfo(sendVerificationEmailDto: SendVerificationEmailDto) : ApiResponse<SendVerificationEmailResponseDto?> = withContext(Dispatchers.IO) {
        val localVariableConfig = sendVerificationEmailRequestConfig(sendVerificationEmailDto = sendVerificationEmailDto)

        return@withContext request<SendVerificationEmailDto, SendVerificationEmailResponseDto>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation sendVerificationEmail
     *
     * @param sendVerificationEmailDto 
     * @return RequestConfig
     */
    fun sendVerificationEmailRequestConfig(sendVerificationEmailDto: SendVerificationEmailDto) : RequestConfig<SendVerificationEmailDto> {
        val localVariableBody = sendVerificationEmailDto
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/canary/authentication/send-verification-email",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * POST /api/canary/authentication/organization/set-active
     * Set Active Organization
     * Set the active organization for the current session
     * @param setActiveOrganizationDto 
     * @return SetActiveOrganizationResponseDto
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun setActiveOrganization(setActiveOrganizationDto: SetActiveOrganizationDto) : SetActiveOrganizationResponseDto = withContext(Dispatchers.IO) {
        val localVarResponse = setActiveOrganizationWithHttpInfo(setActiveOrganizationDto = setActiveOrganizationDto)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as SetActiveOrganizationResponseDto
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /api/canary/authentication/organization/set-active
     * Set Active Organization
     * Set the active organization for the current session
     * @param setActiveOrganizationDto 
     * @return ApiResponse<SetActiveOrganizationResponseDto?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun setActiveOrganizationWithHttpInfo(setActiveOrganizationDto: SetActiveOrganizationDto) : ApiResponse<SetActiveOrganizationResponseDto?> = withContext(Dispatchers.IO) {
        val localVariableConfig = setActiveOrganizationRequestConfig(setActiveOrganizationDto = setActiveOrganizationDto)

        return@withContext request<SetActiveOrganizationDto, SetActiveOrganizationResponseDto>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation setActiveOrganization
     *
     * @param setActiveOrganizationDto 
     * @return RequestConfig
     */
    fun setActiveOrganizationRequestConfig(setActiveOrganizationDto: SetActiveOrganizationDto) : RequestConfig<SetActiveOrganizationDto> {
        val localVariableBody = setActiveOrganizationDto
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/canary/authentication/organization/set-active",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * POST /api/canary/authentication/sign-in/email
     * Sign in with email
     * Authenticate a user using email and password
     * @param signInDto 
     * @return SignInResponseDto
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun signInEmail(signInDto: SignInDto) : SignInResponseDto = withContext(Dispatchers.IO) {
        val localVarResponse = signInEmailWithHttpInfo(signInDto = signInDto)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as SignInResponseDto
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /api/canary/authentication/sign-in/email
     * Sign in with email
     * Authenticate a user using email and password
     * @param signInDto 
     * @return ApiResponse<SignInResponseDto?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun signInEmailWithHttpInfo(signInDto: SignInDto) : ApiResponse<SignInResponseDto?> = withContext(Dispatchers.IO) {
        val localVariableConfig = signInEmailRequestConfig(signInDto = signInDto)

        return@withContext request<SignInDto, SignInResponseDto>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation signInEmail
     *
     * @param signInDto 
     * @return RequestConfig
     */
    fun signInEmailRequestConfig(signInDto: SignInDto) : RequestConfig<SignInDto> {
        val localVariableBody = signInDto
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/canary/authentication/sign-in/email",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * POST /api/canary/authentication/sign-out
     * Sign out
     * Sign out the current user and invalidate the session
     * @return SignOutResponseDto
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun signOut() : SignOutResponseDto = withContext(Dispatchers.IO) {
        val localVarResponse = signOutWithHttpInfo()

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as SignOutResponseDto
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /api/canary/authentication/sign-out
     * Sign out
     * Sign out the current user and invalidate the session
     * @return ApiResponse<SignOutResponseDto?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun signOutWithHttpInfo() : ApiResponse<SignOutResponseDto?> = withContext(Dispatchers.IO) {
        val localVariableConfig = signOutRequestConfig()

        return@withContext request<Unit, SignOutResponseDto>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation signOut
     *
     * @return RequestConfig
     */
    fun signOutRequestConfig() : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/canary/authentication/sign-out",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * POST /api/canary/authentication/sign-up/email
     * Sign up with email
     * Create a new user account using email and password
     * @param signUpDto 
     * @return SignUpResponseDto
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun signUpEmail(signUpDto: SignUpDto) : SignUpResponseDto = withContext(Dispatchers.IO) {
        val localVarResponse = signUpEmailWithHttpInfo(signUpDto = signUpDto)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as SignUpResponseDto
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /api/canary/authentication/sign-up/email
     * Sign up with email
     * Create a new user account using email and password
     * @param signUpDto 
     * @return ApiResponse<SignUpResponseDto?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun signUpEmailWithHttpInfo(signUpDto: SignUpDto) : ApiResponse<SignUpResponseDto?> = withContext(Dispatchers.IO) {
        val localVariableConfig = signUpEmailRequestConfig(signUpDto = signUpDto)

        return@withContext request<SignUpDto, SignUpResponseDto>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation signUpEmail
     *
     * @param signUpDto 
     * @return RequestConfig
     */
    fun signUpEmailRequestConfig(signUpDto: SignUpDto) : RequestConfig<SignUpDto> {
        val localVariableBody = signUpDto
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/canary/authentication/sign-up/email",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * POST /api/canary/authentication/api-key/update
     * Update API Key
     * Update an API key
     * @param updateApiKeyDto 
     * @return UpdateApiKeyResponseDto
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun updateApiKey(updateApiKeyDto: UpdateApiKeyDto) : UpdateApiKeyResponseDto = withContext(Dispatchers.IO) {
        val localVarResponse = updateApiKeyWithHttpInfo(updateApiKeyDto = updateApiKeyDto)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as UpdateApiKeyResponseDto
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /api/canary/authentication/api-key/update
     * Update API Key
     * Update an API key
     * @param updateApiKeyDto 
     * @return ApiResponse<UpdateApiKeyResponseDto?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun updateApiKeyWithHttpInfo(updateApiKeyDto: UpdateApiKeyDto) : ApiResponse<UpdateApiKeyResponseDto?> = withContext(Dispatchers.IO) {
        val localVariableConfig = updateApiKeyRequestConfig(updateApiKeyDto = updateApiKeyDto)

        return@withContext request<UpdateApiKeyDto, UpdateApiKeyResponseDto>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation updateApiKey
     *
     * @param updateApiKeyDto 
     * @return RequestConfig
     */
    fun updateApiKeyRequestConfig(updateApiKeyDto: UpdateApiKeyDto) : RequestConfig<UpdateApiKeyDto> {
        val localVariableBody = updateApiKeyDto
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/canary/authentication/api-key/update",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * POST /api/canary/authentication/organization/update-member-role
     * Update Member Role
     * Update a member&#39;s role in an organization
     * @param updateMemberRoleDto 
     * @return UpdateMemberRoleResponseDto
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun updateMemberRole(updateMemberRoleDto: UpdateMemberRoleDto) : UpdateMemberRoleResponseDto = withContext(Dispatchers.IO) {
        val localVarResponse = updateMemberRoleWithHttpInfo(updateMemberRoleDto = updateMemberRoleDto)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as UpdateMemberRoleResponseDto
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /api/canary/authentication/organization/update-member-role
     * Update Member Role
     * Update a member&#39;s role in an organization
     * @param updateMemberRoleDto 
     * @return ApiResponse<UpdateMemberRoleResponseDto?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun updateMemberRoleWithHttpInfo(updateMemberRoleDto: UpdateMemberRoleDto) : ApiResponse<UpdateMemberRoleResponseDto?> = withContext(Dispatchers.IO) {
        val localVariableConfig = updateMemberRoleRequestConfig(updateMemberRoleDto = updateMemberRoleDto)

        return@withContext request<UpdateMemberRoleDto, UpdateMemberRoleResponseDto>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation updateMemberRole
     *
     * @param updateMemberRoleDto 
     * @return RequestConfig
     */
    fun updateMemberRoleRequestConfig(updateMemberRoleDto: UpdateMemberRoleDto) : RequestConfig<UpdateMemberRoleDto> {
        val localVariableBody = updateMemberRoleDto
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/canary/authentication/organization/update-member-role",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * POST /api/canary/authentication/organization/update
     * Update Organization
     * Update an organization&#39;s details
     * @param updateOrganizationDto 
     * @return UpdateOrganizationResponseDto
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun updateOrganization(updateOrganizationDto: UpdateOrganizationDto) : UpdateOrganizationResponseDto = withContext(Dispatchers.IO) {
        val localVarResponse = updateOrganizationWithHttpInfo(updateOrganizationDto = updateOrganizationDto)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as UpdateOrganizationResponseDto
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /api/canary/authentication/organization/update
     * Update Organization
     * Update an organization&#39;s details
     * @param updateOrganizationDto 
     * @return ApiResponse<UpdateOrganizationResponseDto?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun updateOrganizationWithHttpInfo(updateOrganizationDto: UpdateOrganizationDto) : ApiResponse<UpdateOrganizationResponseDto?> = withContext(Dispatchers.IO) {
        val localVariableConfig = updateOrganizationRequestConfig(updateOrganizationDto = updateOrganizationDto)

        return@withContext request<UpdateOrganizationDto, UpdateOrganizationResponseDto>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation updateOrganization
     *
     * @param updateOrganizationDto 
     * @return RequestConfig
     */
    fun updateOrganizationRequestConfig(updateOrganizationDto: UpdateOrganizationDto) : RequestConfig<UpdateOrganizationDto> {
        val localVariableBody = updateOrganizationDto
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/canary/authentication/organization/update",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * POST /api/canary/authentication/update-user
     * Update User
     * Update the current user&#39;s information
     * @param updateUserDto 
     * @return UpdateUserResponseDto
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun updateUser(updateUserDto: UpdateUserDto) : UpdateUserResponseDto = withContext(Dispatchers.IO) {
        val localVarResponse = updateUserWithHttpInfo(updateUserDto = updateUserDto)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as UpdateUserResponseDto
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /api/canary/authentication/update-user
     * Update User
     * Update the current user&#39;s information
     * @param updateUserDto 
     * @return ApiResponse<UpdateUserResponseDto?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun updateUserWithHttpInfo(updateUserDto: UpdateUserDto) : ApiResponse<UpdateUserResponseDto?> = withContext(Dispatchers.IO) {
        val localVariableConfig = updateUserRequestConfig(updateUserDto = updateUserDto)

        return@withContext request<UpdateUserDto, UpdateUserResponseDto>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation updateUser
     *
     * @param updateUserDto 
     * @return RequestConfig
     */
    fun updateUserRequestConfig(updateUserDto: UpdateUserDto) : RequestConfig<UpdateUserDto> {
        val localVariableBody = updateUserDto
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/canary/authentication/update-user",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * POST /api/canary/authentication/api-key/verify
     * Verify API Key
     * Verify an API key
     * @param verifyApiKeyDto 
     * @return VerifyApiKeyResponseDto
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun verifyApiKey(verifyApiKeyDto: VerifyApiKeyDto) : VerifyApiKeyResponseDto = withContext(Dispatchers.IO) {
        val localVarResponse = verifyApiKeyWithHttpInfo(verifyApiKeyDto = verifyApiKeyDto)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as VerifyApiKeyResponseDto
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /api/canary/authentication/api-key/verify
     * Verify API Key
     * Verify an API key
     * @param verifyApiKeyDto 
     * @return ApiResponse<VerifyApiKeyResponseDto?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun verifyApiKeyWithHttpInfo(verifyApiKeyDto: VerifyApiKeyDto) : ApiResponse<VerifyApiKeyResponseDto?> = withContext(Dispatchers.IO) {
        val localVariableConfig = verifyApiKeyRequestConfig(verifyApiKeyDto = verifyApiKeyDto)

        return@withContext request<VerifyApiKeyDto, VerifyApiKeyResponseDto>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation verifyApiKey
     *
     * @param verifyApiKeyDto 
     * @return RequestConfig
     */
    fun verifyApiKeyRequestConfig(verifyApiKeyDto: VerifyApiKeyDto) : RequestConfig<VerifyApiKeyDto> {
        val localVariableBody = verifyApiKeyDto
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/canary/authentication/api-key/verify",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * GET /api/canary/authentication/verify-email
     * Verify Email
     * Verify the email of a user
     * @param token 
     * @param callbackURL  (optional)
     * @return VerifyEmailResponseDto
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun verifyEmail(token: kotlin.String, callbackURL: kotlin.String? = null) : VerifyEmailResponseDto = withContext(Dispatchers.IO) {
        val localVarResponse = verifyEmailWithHttpInfo(token = token, callbackURL = callbackURL)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as VerifyEmailResponseDto
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /api/canary/authentication/verify-email
     * Verify Email
     * Verify the email of a user
     * @param token 
     * @param callbackURL  (optional)
     * @return ApiResponse<VerifyEmailResponseDto?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun verifyEmailWithHttpInfo(token: kotlin.String, callbackURL: kotlin.String?) : ApiResponse<VerifyEmailResponseDto?> = withContext(Dispatchers.IO) {
        val localVariableConfig = verifyEmailRequestConfig(token = token, callbackURL = callbackURL)

        return@withContext request<Unit, VerifyEmailResponseDto>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation verifyEmail
     *
     * @param token 
     * @param callbackURL  (optional)
     * @return RequestConfig
     */
    fun verifyEmailRequestConfig(token: kotlin.String, callbackURL: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (callbackURL != null) {
                    put("callbackURL", listOf(callbackURL.toString()))
                }
                put("token", listOf(token.toString()))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/canary/authentication/verify-email",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }


    private fun encodeURIComponent(uriComponent: kotlin.String): kotlin.String =
        HttpUrl.Builder().scheme("http").host("localhost").addPathSegment(uriComponent).build().encodedPathSegments[0]
}
