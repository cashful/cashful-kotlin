/**
 *
 * Please note:
 * This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * Do not edit this file manually.
 *
 */

@file:Suppress(
    "ArrayInDataClass",
    "EnumEntryName",
    "RemoveRedundantQualifierName",
    "UnusedImport"
)

package com.cashful.kotlin.sdk.api

import java.io.IOException
import okhttp3.Call
import okhttp3.HttpUrl

import com.cashful.kotlin.sdk.model.ConfirmUploadDto
import com.cashful.kotlin.sdk.model.ErrorResponseDto
import com.cashful.kotlin.sdk.model.FileDto
import com.cashful.kotlin.sdk.model.ListFilesResponseDto
import com.cashful.kotlin.sdk.model.PresignedDownloadResponseDto
import com.cashful.kotlin.sdk.model.PresignedUploadResponseDto
import com.cashful.kotlin.sdk.model.RequestUploadUrlDto

import kotlinx.serialization.SerialName
import kotlinx.serialization.Serializable

import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.withContext
import com.cashful.kotlin.sdk.infrastructure.ApiClient
import com.cashful.kotlin.sdk.infrastructure.ApiResponse
import com.cashful.kotlin.sdk.infrastructure.ClientException
import com.cashful.kotlin.sdk.infrastructure.ClientError
import com.cashful.kotlin.sdk.infrastructure.ServerException
import com.cashful.kotlin.sdk.infrastructure.ServerError
import com.cashful.kotlin.sdk.infrastructure.MultiValueMap
import com.cashful.kotlin.sdk.infrastructure.PartConfig
import com.cashful.kotlin.sdk.infrastructure.RequestConfig
import com.cashful.kotlin.sdk.infrastructure.RequestMethod
import com.cashful.kotlin.sdk.infrastructure.ResponseType
import com.cashful.kotlin.sdk.infrastructure.Success
import com.cashful.kotlin.sdk.infrastructure.toMultiValue

class StorageApi(basePath: kotlin.String = defaultBasePath, client: Call.Factory = ApiClient.defaultClient) : ApiClient(basePath, client) {
    companion object {
        @JvmStatic
        val defaultBasePath: String by lazy {
            System.getProperties().getProperty(ApiClient.baseUrlKey, "https://api.cashful.africa")
        }
    }

    /**
     * POST /api/canary/storage/confirm-upload
     * Confirm that a file upload was completed
     * 
     * @param confirmUploadDto 
     * @return FileDto
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun storageControllerConfirmUploadCanary(confirmUploadDto: ConfirmUploadDto) : FileDto = withContext(Dispatchers.IO) {
        val localVarResponse = storageControllerConfirmUploadCanaryWithHttpInfo(confirmUploadDto = confirmUploadDto)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as FileDto
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /api/canary/storage/confirm-upload
     * Confirm that a file upload was completed
     * 
     * @param confirmUploadDto 
     * @return ApiResponse<FileDto?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun storageControllerConfirmUploadCanaryWithHttpInfo(confirmUploadDto: ConfirmUploadDto) : ApiResponse<FileDto?> = withContext(Dispatchers.IO) {
        val localVariableConfig = storageControllerConfirmUploadCanaryRequestConfig(confirmUploadDto = confirmUploadDto)

        return@withContext request<ConfirmUploadDto, FileDto>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation storageControllerConfirmUploadCanary
     *
     * @param confirmUploadDto 
     * @return RequestConfig
     */
    fun storageControllerConfirmUploadCanaryRequestConfig(confirmUploadDto: ConfirmUploadDto) : RequestConfig<ConfirmUploadDto> {
        val localVariableBody = confirmUploadDto
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/canary/storage/confirm-upload",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * DELETE /api/canary/storage/{id}
     * Delete a file
     * 
     * @param id File ID
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun storageControllerDeleteCanary(id: kotlin.String) : Unit = withContext(Dispatchers.IO) {
        val localVarResponse = storageControllerDeleteCanaryWithHttpInfo(id = id)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * DELETE /api/canary/storage/{id}
     * Delete a file
     * 
     * @param id File ID
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun storageControllerDeleteCanaryWithHttpInfo(id: kotlin.String) : ApiResponse<Unit?> = withContext(Dispatchers.IO) {
        val localVariableConfig = storageControllerDeleteCanaryRequestConfig(id = id)

        return@withContext request<Unit, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation storageControllerDeleteCanary
     *
     * @param id File ID
     * @return RequestConfig
     */
    fun storageControllerDeleteCanaryRequestConfig(id: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.DELETE,
            path = "/api/canary/storage/{id}".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * GET /api/canary/storage/{id}/download-url
     * Get a presigned download URL for a file
     * 
     * @param id File ID
     * @return PresignedDownloadResponseDto
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun storageControllerGetDownloadUrlCanary(id: kotlin.String) : PresignedDownloadResponseDto = withContext(Dispatchers.IO) {
        val localVarResponse = storageControllerGetDownloadUrlCanaryWithHttpInfo(id = id)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as PresignedDownloadResponseDto
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /api/canary/storage/{id}/download-url
     * Get a presigned download URL for a file
     * 
     * @param id File ID
     * @return ApiResponse<PresignedDownloadResponseDto?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun storageControllerGetDownloadUrlCanaryWithHttpInfo(id: kotlin.String) : ApiResponse<PresignedDownloadResponseDto?> = withContext(Dispatchers.IO) {
        val localVariableConfig = storageControllerGetDownloadUrlCanaryRequestConfig(id = id)

        return@withContext request<Unit, PresignedDownloadResponseDto>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation storageControllerGetDownloadUrlCanary
     *
     * @param id File ID
     * @return RequestConfig
     */
    fun storageControllerGetDownloadUrlCanaryRequestConfig(id: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/canary/storage/{id}/download-url".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * enum for parameter status
     */
     enum class StatusStorageControllerListCanary(val value: kotlin.String) {
         @SerialName(value = "pending") pending("pending"),
         @SerialName(value = "uploaded") uploaded("uploaded"),
         @SerialName(value = "failed") failed("failed"),
         @SerialName(value = "deleted") deleted("deleted");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * GET /api/canary/storage
     * List files
     * 
     * @param merchantId The ID of the merchant. This parameter is required.
     * @param limit Maximum number of records to return (optional)
     * @param offset Number of records to skip (optional)
     * @param tag Filter by tag (optional)
     * @param status  (optional)
     * @param relatedEntityId  (optional)
     * @param relatedEntityType  (optional)
     * @return ListFilesResponseDto
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun storageControllerListCanary(merchantId: kotlin.String, limit: java.math.BigDecimal? = null, offset: java.math.BigDecimal? = null, tag: kotlin.String? = null, status: StatusStorageControllerListCanary? = null, relatedEntityId: kotlin.String? = null, relatedEntityType: kotlin.String? = null) : ListFilesResponseDto = withContext(Dispatchers.IO) {
        val localVarResponse = storageControllerListCanaryWithHttpInfo(merchantId = merchantId, limit = limit, offset = offset, tag = tag, status = status, relatedEntityId = relatedEntityId, relatedEntityType = relatedEntityType)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ListFilesResponseDto
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /api/canary/storage
     * List files
     * 
     * @param merchantId The ID of the merchant. This parameter is required.
     * @param limit Maximum number of records to return (optional)
     * @param offset Number of records to skip (optional)
     * @param tag Filter by tag (optional)
     * @param status  (optional)
     * @param relatedEntityId  (optional)
     * @param relatedEntityType  (optional)
     * @return ApiResponse<ListFilesResponseDto?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun storageControllerListCanaryWithHttpInfo(merchantId: kotlin.String, limit: java.math.BigDecimal?, offset: java.math.BigDecimal?, tag: kotlin.String?, status: StatusStorageControllerListCanary?, relatedEntityId: kotlin.String?, relatedEntityType: kotlin.String?) : ApiResponse<ListFilesResponseDto?> = withContext(Dispatchers.IO) {
        val localVariableConfig = storageControllerListCanaryRequestConfig(merchantId = merchantId, limit = limit, offset = offset, tag = tag, status = status, relatedEntityId = relatedEntityId, relatedEntityType = relatedEntityType)

        return@withContext request<Unit, ListFilesResponseDto>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation storageControllerListCanary
     *
     * @param merchantId The ID of the merchant. This parameter is required.
     * @param limit Maximum number of records to return (optional)
     * @param offset Number of records to skip (optional)
     * @param tag Filter by tag (optional)
     * @param status  (optional)
     * @param relatedEntityId  (optional)
     * @param relatedEntityType  (optional)
     * @return RequestConfig
     */
    fun storageControllerListCanaryRequestConfig(merchantId: kotlin.String, limit: java.math.BigDecimal?, offset: java.math.BigDecimal?, tag: kotlin.String?, status: StatusStorageControllerListCanary?, relatedEntityId: kotlin.String?, relatedEntityType: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
                if (offset != null) {
                    put("offset", listOf(offset.toString()))
                }
                if (tag != null) {
                    put("tag", listOf(tag.toString()))
                }
                if (status != null) {
                    put("status", listOf(status.value))
                }
                if (relatedEntityId != null) {
                    put("relatedEntityId", listOf(relatedEntityId.toString()))
                }
                if (relatedEntityType != null) {
                    put("relatedEntityType", listOf(relatedEntityType.toString()))
                }
                put("merchantId", listOf(merchantId.toString()))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/canary/storage",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * POST /api/canary/storage/upload-url
     * Request a presigned URL for file upload
     * 
     * @param requestUploadUrlDto 
     * @return PresignedUploadResponseDto
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun storageControllerRequestUploadUrlCanary(requestUploadUrlDto: RequestUploadUrlDto) : PresignedUploadResponseDto = withContext(Dispatchers.IO) {
        val localVarResponse = storageControllerRequestUploadUrlCanaryWithHttpInfo(requestUploadUrlDto = requestUploadUrlDto)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as PresignedUploadResponseDto
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /api/canary/storage/upload-url
     * Request a presigned URL for file upload
     * 
     * @param requestUploadUrlDto 
     * @return ApiResponse<PresignedUploadResponseDto?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun storageControllerRequestUploadUrlCanaryWithHttpInfo(requestUploadUrlDto: RequestUploadUrlDto) : ApiResponse<PresignedUploadResponseDto?> = withContext(Dispatchers.IO) {
        val localVariableConfig = storageControllerRequestUploadUrlCanaryRequestConfig(requestUploadUrlDto = requestUploadUrlDto)

        return@withContext request<RequestUploadUrlDto, PresignedUploadResponseDto>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation storageControllerRequestUploadUrlCanary
     *
     * @param requestUploadUrlDto 
     * @return RequestConfig
     */
    fun storageControllerRequestUploadUrlCanaryRequestConfig(requestUploadUrlDto: RequestUploadUrlDto) : RequestConfig<RequestUploadUrlDto> {
        val localVariableBody = requestUploadUrlDto
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/canary/storage/upload-url",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * GET /api/canary/storage/{id}
     * Get file details
     * 
     * @param id File ID
     * @return FileDto
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun storageControllerRetrieveCanary(id: kotlin.String) : FileDto = withContext(Dispatchers.IO) {
        val localVarResponse = storageControllerRetrieveCanaryWithHttpInfo(id = id)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as FileDto
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /api/canary/storage/{id}
     * Get file details
     * 
     * @param id File ID
     * @return ApiResponse<FileDto?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun storageControllerRetrieveCanaryWithHttpInfo(id: kotlin.String) : ApiResponse<FileDto?> = withContext(Dispatchers.IO) {
        val localVariableConfig = storageControllerRetrieveCanaryRequestConfig(id = id)

        return@withContext request<Unit, FileDto>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation storageControllerRetrieveCanary
     *
     * @param id File ID
     * @return RequestConfig
     */
    fun storageControllerRetrieveCanaryRequestConfig(id: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/canary/storage/{id}".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }


    private fun encodeURIComponent(uriComponent: kotlin.String): kotlin.String =
        HttpUrl.Builder().scheme("http").host("localhost").addPathSegment(uriComponent).build().encodedPathSegments[0]
}
