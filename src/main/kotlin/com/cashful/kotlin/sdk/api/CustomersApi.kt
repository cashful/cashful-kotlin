/**
 *
 * Please note:
 * This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * Do not edit this file manually.
 *
 */

@file:Suppress(
    "ArrayInDataClass",
    "EnumEntryName",
    "RemoveRedundantQualifierName",
    "UnusedImport"
)

package com.cashful.kotlin.sdk.api

import java.io.IOException
import okhttp3.Call
import okhttp3.HttpUrl

import com.cashful.kotlin.sdk.model.CreateCustomerDto
import com.cashful.kotlin.sdk.model.CustomerResponseDto
import com.cashful.kotlin.sdk.model.ErrorResponseDto
import com.cashful.kotlin.sdk.model.ListCustomerTransactionsResponseDto
import com.cashful.kotlin.sdk.model.ListCustomersResponseDto
import com.cashful.kotlin.sdk.model.UpdateCustomerDto

import kotlinx.serialization.SerialName
import kotlinx.serialization.Serializable

import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.withContext
import com.cashful.kotlin.sdk.infrastructure.ApiClient
import com.cashful.kotlin.sdk.infrastructure.ApiResponse
import com.cashful.kotlin.sdk.infrastructure.ClientException
import com.cashful.kotlin.sdk.infrastructure.ClientError
import com.cashful.kotlin.sdk.infrastructure.ServerException
import com.cashful.kotlin.sdk.infrastructure.ServerError
import com.cashful.kotlin.sdk.infrastructure.MultiValueMap
import com.cashful.kotlin.sdk.infrastructure.PartConfig
import com.cashful.kotlin.sdk.infrastructure.RequestConfig
import com.cashful.kotlin.sdk.infrastructure.RequestMethod
import com.cashful.kotlin.sdk.infrastructure.ResponseType
import com.cashful.kotlin.sdk.infrastructure.Success
import com.cashful.kotlin.sdk.infrastructure.toMultiValue

class CustomersApi(basePath: kotlin.String = defaultBasePath, client: Call.Factory = ApiClient.defaultClient) : ApiClient(basePath, client) {
    companion object {
        @JvmStatic
        val defaultBasePath: String by lazy {
            System.getProperties().getProperty(ApiClient.baseUrlKey, "https://api.cashful.africa")
        }
    }

    /**
     * POST /api/canary/customers
     * Create Customer
     * Creates a new customer object. This also provisions their \&quot;cash balance\&quot; feature (starting at 0).
     * @param createCustomerDto Customer details
     * @return CustomerResponseDto
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun createCustomer(createCustomerDto: CreateCustomerDto) : CustomerResponseDto = withContext(Dispatchers.IO) {
        val localVarResponse = createCustomerWithHttpInfo(createCustomerDto = createCustomerDto)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as CustomerResponseDto
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /api/canary/customers
     * Create Customer
     * Creates a new customer object. This also provisions their \&quot;cash balance\&quot; feature (starting at 0).
     * @param createCustomerDto Customer details
     * @return ApiResponse<CustomerResponseDto?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun createCustomerWithHttpInfo(createCustomerDto: CreateCustomerDto) : ApiResponse<CustomerResponseDto?> = withContext(Dispatchers.IO) {
        val localVariableConfig = createCustomerRequestConfig(createCustomerDto = createCustomerDto)

        return@withContext request<CreateCustomerDto, CustomerResponseDto>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation createCustomer
     *
     * @param createCustomerDto Customer details
     * @return RequestConfig
     */
    fun createCustomerRequestConfig(createCustomerDto: CreateCustomerDto) : RequestConfig<CreateCustomerDto> {
        val localVariableBody = createCustomerDto
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/canary/customers",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * GET /api/canary/customers/{id}/balance
     * Get Customer&#39;s Cash Balance
     * Retrieves the real-time balance for a single customer&#39;s \&quot;cash balance\&quot; (the \&quot;wallet-enabling\&quot; feature).
     * @param id The unique identifier of the customer
     * @return kotlin.Any
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun getCustomerBalance(id: kotlin.String) : kotlin.Any = withContext(Dispatchers.IO) {
        val localVarResponse = getCustomerBalanceWithHttpInfo(id = id)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.Any
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /api/canary/customers/{id}/balance
     * Get Customer&#39;s Cash Balance
     * Retrieves the real-time balance for a single customer&#39;s \&quot;cash balance\&quot; (the \&quot;wallet-enabling\&quot; feature).
     * @param id The unique identifier of the customer
     * @return ApiResponse<kotlin.Any?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun getCustomerBalanceWithHttpInfo(id: kotlin.String) : ApiResponse<kotlin.Any?> = withContext(Dispatchers.IO) {
        val localVariableConfig = getCustomerBalanceRequestConfig(id = id)

        return@withContext request<Unit, kotlin.Any>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getCustomerBalance
     *
     * @param id The unique identifier of the customer
     * @return RequestConfig
     */
    fun getCustomerBalanceRequestConfig(id: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/canary/customers/{id}/balance".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * GET /api/canary/customers/{id}/payment-methods
     * List Customer&#39;s Payment Methods
     * Shows all saved payment methods (cards, etc.) for a single customer.
     * @param id The unique identifier of the customer
     * @param limit Maximum number of records to return (optional)
     * @param offset Number of records to skip (optional)
     * @return kotlin.Any
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun listCustomerPaymentMethods(id: kotlin.String, limit: java.math.BigDecimal? = null, offset: java.math.BigDecimal? = null) : kotlin.Any = withContext(Dispatchers.IO) {
        val localVarResponse = listCustomerPaymentMethodsWithHttpInfo(id = id, limit = limit, offset = offset)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.Any
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /api/canary/customers/{id}/payment-methods
     * List Customer&#39;s Payment Methods
     * Shows all saved payment methods (cards, etc.) for a single customer.
     * @param id The unique identifier of the customer
     * @param limit Maximum number of records to return (optional)
     * @param offset Number of records to skip (optional)
     * @return ApiResponse<kotlin.Any?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun listCustomerPaymentMethodsWithHttpInfo(id: kotlin.String, limit: java.math.BigDecimal?, offset: java.math.BigDecimal?) : ApiResponse<kotlin.Any?> = withContext(Dispatchers.IO) {
        val localVariableConfig = listCustomerPaymentMethodsRequestConfig(id = id, limit = limit, offset = offset)

        return@withContext request<Unit, kotlin.Any>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation listCustomerPaymentMethods
     *
     * @param id The unique identifier of the customer
     * @param limit Maximum number of records to return (optional)
     * @param offset Number of records to skip (optional)
     * @return RequestConfig
     */
    fun listCustomerPaymentMethodsRequestConfig(id: kotlin.String, limit: java.math.BigDecimal?, offset: java.math.BigDecimal?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
                if (offset != null) {
                    put("offset", listOf(offset.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/canary/customers/{id}/payment-methods".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * GET /api/canary/customers/{id}/transactions
     * List Customer&#39;s Cash Transactions
     * Provides the full transaction history for a single customer&#39;s \&quot;cash balance\&quot; (Pay-Ins, Purchases, Transfers).
     * @param id The unique identifier of the customer
     * @param limit Maximum number of records to return (optional)
     * @param offset Number of records to skip (optional)
     * @return ListCustomerTransactionsResponseDto
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun listCustomerTransactions(id: kotlin.String, limit: java.math.BigDecimal? = null, offset: java.math.BigDecimal? = null) : ListCustomerTransactionsResponseDto = withContext(Dispatchers.IO) {
        val localVarResponse = listCustomerTransactionsWithHttpInfo(id = id, limit = limit, offset = offset)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ListCustomerTransactionsResponseDto
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /api/canary/customers/{id}/transactions
     * List Customer&#39;s Cash Transactions
     * Provides the full transaction history for a single customer&#39;s \&quot;cash balance\&quot; (Pay-Ins, Purchases, Transfers).
     * @param id The unique identifier of the customer
     * @param limit Maximum number of records to return (optional)
     * @param offset Number of records to skip (optional)
     * @return ApiResponse<ListCustomerTransactionsResponseDto?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun listCustomerTransactionsWithHttpInfo(id: kotlin.String, limit: java.math.BigDecimal?, offset: java.math.BigDecimal?) : ApiResponse<ListCustomerTransactionsResponseDto?> = withContext(Dispatchers.IO) {
        val localVariableConfig = listCustomerTransactionsRequestConfig(id = id, limit = limit, offset = offset)

        return@withContext request<Unit, ListCustomerTransactionsResponseDto>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation listCustomerTransactions
     *
     * @param id The unique identifier of the customer
     * @param limit Maximum number of records to return (optional)
     * @param offset Number of records to skip (optional)
     * @return RequestConfig
     */
    fun listCustomerTransactionsRequestConfig(id: kotlin.String, limit: java.math.BigDecimal?, offset: java.math.BigDecimal?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
                if (offset != null) {
                    put("offset", listOf(offset.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/canary/customers/{id}/transactions".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * GET /api/canary/customers
     * List Customers
     * Retrieves a paginated list of all customers for the merchant.
     * @param merchantId The ID of the merchant. This parameter is required.
     * @param limit Maximum number of records to return (optional)
     * @param offset Number of records to skip (optional)
     * @param email Filter by email address (optional)
     * @param search Search across customer fields (optional)
     * @return ListCustomersResponseDto
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun listCustomers(merchantId: kotlin.String, limit: java.math.BigDecimal? = null, offset: java.math.BigDecimal? = null, email: kotlin.String? = null, search: kotlin.String? = null) : ListCustomersResponseDto = withContext(Dispatchers.IO) {
        val localVarResponse = listCustomersWithHttpInfo(merchantId = merchantId, limit = limit, offset = offset, email = email, search = search)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ListCustomersResponseDto
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /api/canary/customers
     * List Customers
     * Retrieves a paginated list of all customers for the merchant.
     * @param merchantId The ID of the merchant. This parameter is required.
     * @param limit Maximum number of records to return (optional)
     * @param offset Number of records to skip (optional)
     * @param email Filter by email address (optional)
     * @param search Search across customer fields (optional)
     * @return ApiResponse<ListCustomersResponseDto?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun listCustomersWithHttpInfo(merchantId: kotlin.String, limit: java.math.BigDecimal?, offset: java.math.BigDecimal?, email: kotlin.String?, search: kotlin.String?) : ApiResponse<ListCustomersResponseDto?> = withContext(Dispatchers.IO) {
        val localVariableConfig = listCustomersRequestConfig(merchantId = merchantId, limit = limit, offset = offset, email = email, search = search)

        return@withContext request<Unit, ListCustomersResponseDto>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation listCustomers
     *
     * @param merchantId The ID of the merchant. This parameter is required.
     * @param limit Maximum number of records to return (optional)
     * @param offset Number of records to skip (optional)
     * @param email Filter by email address (optional)
     * @param search Search across customer fields (optional)
     * @return RequestConfig
     */
    fun listCustomersRequestConfig(merchantId: kotlin.String, limit: java.math.BigDecimal?, offset: java.math.BigDecimal?, email: kotlin.String?, search: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("merchantId", listOf(merchantId.toString()))
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
                if (offset != null) {
                    put("offset", listOf(offset.toString()))
                }
                if (email != null) {
                    put("email", listOf(email.toString()))
                }
                if (search != null) {
                    put("search", listOf(search.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/canary/customers",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * GET /api/canary/customers/{id}
     * Retrieve Customer
     * Gets the details for a single customer.
     * @param id The unique identifier of the customer
     * @return kotlin.Any
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun retrieveCustomer(id: kotlin.String) : kotlin.Any = withContext(Dispatchers.IO) {
        val localVarResponse = retrieveCustomerWithHttpInfo(id = id)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.Any
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /api/canary/customers/{id}
     * Retrieve Customer
     * Gets the details for a single customer.
     * @param id The unique identifier of the customer
     * @return ApiResponse<kotlin.Any?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun retrieveCustomerWithHttpInfo(id: kotlin.String) : ApiResponse<kotlin.Any?> = withContext(Dispatchers.IO) {
        val localVariableConfig = retrieveCustomerRequestConfig(id = id)

        return@withContext request<Unit, kotlin.Any>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation retrieveCustomer
     *
     * @param id The unique identifier of the customer
     * @return RequestConfig
     */
    fun retrieveCustomerRequestConfig(id: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/canary/customers/{id}".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * PATCH /api/canary/customers/{id}
     * Update Customer
     * Updates a customer&#39;s details (e.g., email, metadata).
     * @param id The unique identifier of the customer
     * @param updateCustomerDto Customer update details
     * @return kotlin.Any
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun updateCustomer(id: kotlin.String, updateCustomerDto: UpdateCustomerDto) : kotlin.Any = withContext(Dispatchers.IO) {
        val localVarResponse = updateCustomerWithHttpInfo(id = id, updateCustomerDto = updateCustomerDto)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.Any
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * PATCH /api/canary/customers/{id}
     * Update Customer
     * Updates a customer&#39;s details (e.g., email, metadata).
     * @param id The unique identifier of the customer
     * @param updateCustomerDto Customer update details
     * @return ApiResponse<kotlin.Any?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun updateCustomerWithHttpInfo(id: kotlin.String, updateCustomerDto: UpdateCustomerDto) : ApiResponse<kotlin.Any?> = withContext(Dispatchers.IO) {
        val localVariableConfig = updateCustomerRequestConfig(id = id, updateCustomerDto = updateCustomerDto)

        return@withContext request<UpdateCustomerDto, kotlin.Any>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation updateCustomer
     *
     * @param id The unique identifier of the customer
     * @param updateCustomerDto Customer update details
     * @return RequestConfig
     */
    fun updateCustomerRequestConfig(id: kotlin.String, updateCustomerDto: UpdateCustomerDto) : RequestConfig<UpdateCustomerDto> {
        val localVariableBody = updateCustomerDto
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.PATCH,
            path = "/api/canary/customers/{id}".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }


    private fun encodeURIComponent(uriComponent: kotlin.String): kotlin.String =
        HttpUrl.Builder().scheme("http").host("localhost").addPathSegment(uriComponent).build().encodedPathSegments[0]
}
