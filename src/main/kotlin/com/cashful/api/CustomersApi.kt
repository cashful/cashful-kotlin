/**
 *
 * Please note:
 * This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * Do not edit this file manually.
 *
 */

@file:Suppress(
    "ArrayInDataClass",
    "EnumEntryName",
    "RemoveRedundantQualifierName",
    "UnusedImport"
)

package com.cashful.api

import java.io.IOException
import okhttp3.Call
import okhttp3.HttpUrl

import com.cashful.model.BadRequestResponseDto
import com.cashful.model.CreateCustomerDto
import com.cashful.model.CustomerBalanceDto
import com.cashful.model.CustomerResponseDto
import com.cashful.model.InternalServerErrorResponseDto
import com.cashful.model.ListCustomerPaymentMethodsResponseDto
import com.cashful.model.ListCustomerTransactionsResponseDto
import com.cashful.model.ListCustomersResponseDto
import com.cashful.model.NotFoundResponseDto
import com.cashful.model.UnauthorizedResponseDto
import com.cashful.model.UpdateCustomerDto

import kotlinx.serialization.SerialName
import kotlinx.serialization.Serializable

import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.withContext
import com.cashful.infrastructure.ApiClient
import com.cashful.infrastructure.ApiResponse
import com.cashful.infrastructure.ClientException
import com.cashful.infrastructure.ClientError
import com.cashful.infrastructure.ServerException
import com.cashful.infrastructure.ServerError
import com.cashful.infrastructure.MultiValueMap
import com.cashful.infrastructure.PartConfig
import com.cashful.infrastructure.RequestConfig
import com.cashful.infrastructure.RequestMethod
import com.cashful.infrastructure.ResponseType
import com.cashful.infrastructure.Success
import com.cashful.infrastructure.toMultiValue

class CustomersApi(basePath: kotlin.String = defaultBasePath, client: Call.Factory = ApiClient.defaultClient) : ApiClient(basePath, client) {
    companion object {
        @JvmStatic
        val defaultBasePath: String by lazy {
            System.getProperties().getProperty(ApiClient.baseUrlKey, "https://api.cashful.africa")
        }
    }

    /**
     * POST /api/canary/customers
     * Create Customer
     * Creates a new customer object. This also provisions their \&quot;cash balance\&quot; feature (starting at 0).
     * @param createCustomerDto Customer details
     * @return CustomerResponseDto
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun createCustomer(createCustomerDto: CreateCustomerDto) : CustomerResponseDto = withContext(Dispatchers.IO) {
        val localVarResponse = createCustomerWithHttpInfo(createCustomerDto = createCustomerDto)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as CustomerResponseDto
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * POST /api/canary/customers
     * Create Customer
     * Creates a new customer object. This also provisions their \&quot;cash balance\&quot; feature (starting at 0).
     * @param createCustomerDto Customer details
     * @return ApiResponse<CustomerResponseDto?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun createCustomerWithHttpInfo(createCustomerDto: CreateCustomerDto) : ApiResponse<CustomerResponseDto?> = withContext(Dispatchers.IO) {
        val localVariableConfig = createCustomerRequestConfig(createCustomerDto = createCustomerDto)

        return@withContext request<CreateCustomerDto, CustomerResponseDto>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation createCustomer
     *
     * @param createCustomerDto Customer details
     * @return RequestConfig
     */
    fun createCustomerRequestConfig(createCustomerDto: CreateCustomerDto) : RequestConfig<CreateCustomerDto> {
        val localVariableBody = createCustomerDto
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/canary/customers",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * GET /api/canary/customers/{id}/balance
     * Get Customer&#39;s Cash Balance
     * Retrieves the real-time balance for a single customer&#39;s \&quot;cash balance\&quot; (the \&quot;wallet-enabling\&quot; feature).
     * @param id The unique identifier of the customer
     * @return CustomerBalanceDto
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun getCustomerBalance(id: kotlin.String) : CustomerBalanceDto = withContext(Dispatchers.IO) {
        val localVarResponse = getCustomerBalanceWithHttpInfo(id = id)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as CustomerBalanceDto
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /api/canary/customers/{id}/balance
     * Get Customer&#39;s Cash Balance
     * Retrieves the real-time balance for a single customer&#39;s \&quot;cash balance\&quot; (the \&quot;wallet-enabling\&quot; feature).
     * @param id The unique identifier of the customer
     * @return ApiResponse<CustomerBalanceDto?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun getCustomerBalanceWithHttpInfo(id: kotlin.String) : ApiResponse<CustomerBalanceDto?> = withContext(Dispatchers.IO) {
        val localVariableConfig = getCustomerBalanceRequestConfig(id = id)

        return@withContext request<Unit, CustomerBalanceDto>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getCustomerBalance
     *
     * @param id The unique identifier of the customer
     * @return RequestConfig
     */
    fun getCustomerBalanceRequestConfig(id: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/canary/customers/{id}/balance".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * GET /api/canary/customers/{id}/payment-methods
     * List Customer&#39;s Payment Methods
     * Shows all saved payment methods (cards, etc.) for a single customer.
     * @param id The unique identifier of the customer
     * @param limit Maximum number of records to return (optional)
     * @param offset Number of records to skip (optional)
     * @return ListCustomerPaymentMethodsResponseDto
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun listCustomerPaymentMethods(id: kotlin.String, limit: java.math.BigDecimal? = null, offset: java.math.BigDecimal? = null) : ListCustomerPaymentMethodsResponseDto = withContext(Dispatchers.IO) {
        val localVarResponse = listCustomerPaymentMethodsWithHttpInfo(id = id, limit = limit, offset = offset)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ListCustomerPaymentMethodsResponseDto
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /api/canary/customers/{id}/payment-methods
     * List Customer&#39;s Payment Methods
     * Shows all saved payment methods (cards, etc.) for a single customer.
     * @param id The unique identifier of the customer
     * @param limit Maximum number of records to return (optional)
     * @param offset Number of records to skip (optional)
     * @return ApiResponse<ListCustomerPaymentMethodsResponseDto?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun listCustomerPaymentMethodsWithHttpInfo(id: kotlin.String, limit: java.math.BigDecimal?, offset: java.math.BigDecimal?) : ApiResponse<ListCustomerPaymentMethodsResponseDto?> = withContext(Dispatchers.IO) {
        val localVariableConfig = listCustomerPaymentMethodsRequestConfig(id = id, limit = limit, offset = offset)

        return@withContext request<Unit, ListCustomerPaymentMethodsResponseDto>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation listCustomerPaymentMethods
     *
     * @param id The unique identifier of the customer
     * @param limit Maximum number of records to return (optional)
     * @param offset Number of records to skip (optional)
     * @return RequestConfig
     */
    fun listCustomerPaymentMethodsRequestConfig(id: kotlin.String, limit: java.math.BigDecimal?, offset: java.math.BigDecimal?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
                if (offset != null) {
                    put("offset", listOf(offset.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/canary/customers/{id}/payment-methods".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * GET /api/canary/customers/{id}/transactions
     * List Customer&#39;s Cash Transactions
     * Provides the full transaction history for a single customer&#39;s \&quot;cash balance\&quot; (Pay-Ins, Purchases, Transfers).
     * @param id The unique identifier of the customer
     * @param limit Maximum number of records to return (optional)
     * @param offset Number of records to skip (optional)
     * @return ListCustomerTransactionsResponseDto
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun listCustomerTransactions(id: kotlin.String, limit: java.math.BigDecimal? = null, offset: java.math.BigDecimal? = null) : ListCustomerTransactionsResponseDto = withContext(Dispatchers.IO) {
        val localVarResponse = listCustomerTransactionsWithHttpInfo(id = id, limit = limit, offset = offset)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ListCustomerTransactionsResponseDto
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /api/canary/customers/{id}/transactions
     * List Customer&#39;s Cash Transactions
     * Provides the full transaction history for a single customer&#39;s \&quot;cash balance\&quot; (Pay-Ins, Purchases, Transfers).
     * @param id The unique identifier of the customer
     * @param limit Maximum number of records to return (optional)
     * @param offset Number of records to skip (optional)
     * @return ApiResponse<ListCustomerTransactionsResponseDto?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun listCustomerTransactionsWithHttpInfo(id: kotlin.String, limit: java.math.BigDecimal?, offset: java.math.BigDecimal?) : ApiResponse<ListCustomerTransactionsResponseDto?> = withContext(Dispatchers.IO) {
        val localVariableConfig = listCustomerTransactionsRequestConfig(id = id, limit = limit, offset = offset)

        return@withContext request<Unit, ListCustomerTransactionsResponseDto>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation listCustomerTransactions
     *
     * @param id The unique identifier of the customer
     * @param limit Maximum number of records to return (optional)
     * @param offset Number of records to skip (optional)
     * @return RequestConfig
     */
    fun listCustomerTransactionsRequestConfig(id: kotlin.String, limit: java.math.BigDecimal?, offset: java.math.BigDecimal?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
                if (offset != null) {
                    put("offset", listOf(offset.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/canary/customers/{id}/transactions".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * GET /api/canary/customers
     * List Customers
     * Retrieves a paginated list of all customers for the merchant.
     * @param merchantId The ID of the merchant whose balance is being requested. If omitted, defaults to the authenticated merchant. (optional)
     * @param limit Maximum number of records to return (optional)
     * @param offset Number of records to skip (optional)
     * @param email Filter by email address (optional)
     * @param search Search across customer fields (optional)
     * @return ListCustomersResponseDto
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun listCustomers(merchantId: kotlin.String? = null, limit: java.math.BigDecimal? = null, offset: java.math.BigDecimal? = null, email: kotlin.String? = null, search: kotlin.String? = null) : ListCustomersResponseDto = withContext(Dispatchers.IO) {
        val localVarResponse = listCustomersWithHttpInfo(merchantId = merchantId, limit = limit, offset = offset, email = email, search = search)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ListCustomersResponseDto
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /api/canary/customers
     * List Customers
     * Retrieves a paginated list of all customers for the merchant.
     * @param merchantId The ID of the merchant whose balance is being requested. If omitted, defaults to the authenticated merchant. (optional)
     * @param limit Maximum number of records to return (optional)
     * @param offset Number of records to skip (optional)
     * @param email Filter by email address (optional)
     * @param search Search across customer fields (optional)
     * @return ApiResponse<ListCustomersResponseDto?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun listCustomersWithHttpInfo(merchantId: kotlin.String?, limit: java.math.BigDecimal?, offset: java.math.BigDecimal?, email: kotlin.String?, search: kotlin.String?) : ApiResponse<ListCustomersResponseDto?> = withContext(Dispatchers.IO) {
        val localVariableConfig = listCustomersRequestConfig(merchantId = merchantId, limit = limit, offset = offset, email = email, search = search)

        return@withContext request<Unit, ListCustomersResponseDto>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation listCustomers
     *
     * @param merchantId The ID of the merchant whose balance is being requested. If omitted, defaults to the authenticated merchant. (optional)
     * @param limit Maximum number of records to return (optional)
     * @param offset Number of records to skip (optional)
     * @param email Filter by email address (optional)
     * @param search Search across customer fields (optional)
     * @return RequestConfig
     */
    fun listCustomersRequestConfig(merchantId: kotlin.String?, limit: java.math.BigDecimal?, offset: java.math.BigDecimal?, email: kotlin.String?, search: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (merchantId != null) {
                    put("merchantId", listOf(merchantId.toString()))
                }
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
                if (offset != null) {
                    put("offset", listOf(offset.toString()))
                }
                if (email != null) {
                    put("email", listOf(email.toString()))
                }
                if (search != null) {
                    put("search", listOf(search.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/canary/customers",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * GET /api/canary/customers/{id}
     * Retrieve Customer
     * Gets the details for a single customer.
     * @param id The unique identifier of the customer
     * @return CustomerResponseDto
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun retrieveCustomer(id: kotlin.String) : CustomerResponseDto = withContext(Dispatchers.IO) {
        val localVarResponse = retrieveCustomerWithHttpInfo(id = id)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as CustomerResponseDto
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /api/canary/customers/{id}
     * Retrieve Customer
     * Gets the details for a single customer.
     * @param id The unique identifier of the customer
     * @return ApiResponse<CustomerResponseDto?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun retrieveCustomerWithHttpInfo(id: kotlin.String) : ApiResponse<CustomerResponseDto?> = withContext(Dispatchers.IO) {
        val localVariableConfig = retrieveCustomerRequestConfig(id = id)

        return@withContext request<Unit, CustomerResponseDto>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation retrieveCustomer
     *
     * @param id The unique identifier of the customer
     * @return RequestConfig
     */
    fun retrieveCustomerRequestConfig(id: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/canary/customers/{id}".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * PATCH /api/canary/customers/{id}
     * Update Customer
     * Updates a customer&#39;s details (e.g., email, metadata).
     * @param id The unique identifier of the customer
     * @param updateCustomerDto Customer update details
     * @return CustomerResponseDto
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    suspend fun updateCustomer(id: kotlin.String, updateCustomerDto: UpdateCustomerDto) : CustomerResponseDto = withContext(Dispatchers.IO) {
        val localVarResponse = updateCustomerWithHttpInfo(id = id, updateCustomerDto = updateCustomerDto)

        return@withContext when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as CustomerResponseDto
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * PATCH /api/canary/customers/{id}
     * Update Customer
     * Updates a customer&#39;s details (e.g., email, metadata).
     * @param id The unique identifier of the customer
     * @param updateCustomerDto Customer update details
     * @return ApiResponse<CustomerResponseDto?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    suspend fun updateCustomerWithHttpInfo(id: kotlin.String, updateCustomerDto: UpdateCustomerDto) : ApiResponse<CustomerResponseDto?> = withContext(Dispatchers.IO) {
        val localVariableConfig = updateCustomerRequestConfig(id = id, updateCustomerDto = updateCustomerDto)

        return@withContext request<UpdateCustomerDto, CustomerResponseDto>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation updateCustomer
     *
     * @param id The unique identifier of the customer
     * @param updateCustomerDto Customer update details
     * @return RequestConfig
     */
    fun updateCustomerRequestConfig(id: kotlin.String, updateCustomerDto: UpdateCustomerDto) : RequestConfig<UpdateCustomerDto> {
        val localVariableBody = updateCustomerDto
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.PATCH,
            path = "/api/canary/customers/{id}".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }


    private fun encodeURIComponent(uriComponent: kotlin.String): kotlin.String =
        HttpUrl.Builder().scheme("http").host("localhost").addPathSegment(uriComponent).build().encodedPathSegments[0]
}
